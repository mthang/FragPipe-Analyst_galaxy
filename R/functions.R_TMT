
matrixplot_modify<-function(data, mapping, pts=list(), smt=list(), ...){
    ggplot(data = data, mapping = mapping, ...) + 
        do.call(geom_point, pts) +
        do.call(geom_smooth, smt) 
}

coef_variation<-function(x){
  coef=sd(x)/mean(x)
}

#### Plot CVs

plot_cvs<-function(se) {
  
  ## backtransform data
  untransformed_intensity<- 2^(assay(se))
  exp_design<-colData(se)

### merge untransformed to exp design and calculate cvs
  
  cvs_group<- untransformed_intensity %>% data.frame() %>%
    tibble::rownames_to_column() %>%
    tidyr::gather("ID", "Intensity", -rowname) %>%
    dplyr::left_join(.,data.frame(exp_design), by="ID") %>%
    dplyr::group_by(rowname,condition) %>%
    dplyr::summarise(cvs=coef_variation(Intensity)) %>%
    dplyr::group_by(condition)%>%
    dplyr::mutate(condition_median=median(cvs))
  
p1 <-  ggplot(cvs_group, aes(cvs, color=condition, fill=condition)) +
    geom_histogram(alpha=.5, bins= 20, show.legend = FALSE) +
    facet_wrap(~condition) +
    geom_vline(aes(xintercept=condition_median, group=condition),color='grey40',
             linetype="dashed") +
    labs(title= 'Sample Coefficient of Variation', x="Coefficient of Variation", y="Count") +
    theme_DEP2() +
    theme(plot.title = element_text(hjust = 0.5,face = "bold")) 

p1 +geom_text(aes(x=max(cvs_group$cvs)-0.6,
                  y=max(ggplot_build(p1)$data[[1]]$ymax*1.1), 
                  label=paste0("Median =",round(condition_median,2)*100,"%",by="")),
              show.legend = FALSE, size=4)

}


#### Get individual clusters from heatmap
get_cluster_heatmap <- function(dep, type = c("contrast", "centered"),
                                kmeans = FALSE, k = 6,
                                cluster_columns = TRUE,
                                col_limit = 6, indicate = NULL,
                                clustering_distance = c("euclidean", "maximum", "manhattan", "canberra",
                                                        "binary", "minkowski", "pearson", "spearman", "kendall", "gower"),
                                row_font_size = 6, col_font_size = 10, plot = TRUE, ...) {
  
  # Show error if inputs are not the required classes
  if(is.integer(k)) k <- as.numeric(k)
  if(is.integer(col_limit)) col_limit <- as.numeric(col_limit)
  if(is.integer(row_font_size)) row_font_size <- as.numeric(row_font_size)
  if(is.integer(col_font_size)) col_font_size <- as.numeric(col_font_size)
  assertthat::assert_that(inherits(dep, "SummarizedExperiment"),
                          is.character(type),
                          is.logical(kmeans),
                          is.numeric(k),
                          length(k) == 1,
                          is.logical(cluster_columns),
                          is.numeric(col_limit),
                          length(col_limit) == 1,
                          is.numeric(row_font_size),
                          length(row_font_size) == 1,
                          is.numeric(col_font_size),
                          length(col_font_size) == 1,
                          is.logical(plot),
                          length(plot) == 1)
  
  # Show error if inputs do not contain required columns
  type <- match.arg(type)
  clustering_distance <- match.arg(clustering_distance)
  
  # Extract row and col data
  row_data <- rowData(dep)
  col_data <- colData(dep) %>%
    as.data.frame()
  
  # Show error if inputs do not contain required columns
  if(any(!c("label", "condition", "replicate") %in% colnames(col_data))) {
    stop(paste0("'label', 'condition' and/or 'replicate' columns are not present in '",
                deparse(substitute(dep)), "'"),
         call. = FALSE)
  }
  if(length(grep("_diff", colnames(row_data))) < 1) {
    stop(paste0("'[contrast]_diff' columns are not present in '",
                deparse(substitute(dep)),
                "'.\nRun test_diff() to obtain the required columns."),
         call. = FALSE)
  }
  if(!"significant" %in% colnames(row_data)) {
    stop(paste0("'significant' column is not present in '",
                deparse(substitute(dep)),
                "'.\nRun add_rejections() to obtain the required column."),
         call. = FALSE)
  }
  
  # Heatmap annotation
  if(!is.null(indicate) & type == "contrast") {
    warning("Heatmap annotation only applicable for type = 'centered'",
            call. = FALSE)
  }
  if(!is.null(indicate) & type == "centered") {
    ha1 <- get_annotation(dep, indicate)
  } else {
    ha1 <- NULL
  }
  
  # Filter for significant proteins only
  filtered <- dep[row_data$significant, ]
  
  # Check for missing values
  if(any(is.na(assay(filtered)))) {
    warning("Missing values in '", deparse(substitute(dep)), "'. ",
            "Using clustering_distance = 'gower'",
            call. = FALSE)
    clustering_distance <- "gower"
    obs_NA <- TRUE
  } else {
    obs_NA <- FALSE
  }
  
  # Get centered intensity values ('centered')
  if(type == "centered") {
    rowData(filtered)$mean <- rowMeans(assay(filtered), na.rm = TRUE)
    df <- assay(filtered) - rowData(filtered)$mean
  }
  # Get contrast fold changes ('contrast')
  if(type == "contrast") {
    df <- rowData(filtered) %>%
      data.frame() %>%
      # column_to_rownames(var = "name") %>%
      select(dplyr::ends_with("_diff"))
    colnames(df) <-
      gsub("_diff", "", colnames(df)) %>%
      gsub("_vs_", " vs ", .)
  }
  
  # Facultative kmeans clustering
  if(kmeans & obs_NA) {
    warning("Cannot perform kmeans clustering with missing values",
            call. = FALSE)
    kmeans <- FALSE
  }
  if(kmeans & !obs_NA) {
    set.seed(1)
    
    if(k < nrow(df)| (k == 1 & nrow(df) == 1)){
      df_kmeans <- kmeans(df, k)
      if(type == "centered") {
        # Order the k-means clusters according to the maximum fold change
        # in all samples averaged over the proteins in the cluster
        order <- data.frame(df) %>%
          cbind(., cluster = df_kmeans$cluster) %>%
          dplyr::mutate(row = apply(.[, seq_len(ncol(.) - 1)], 1, function(x) max(x))) %>%
          dplyr::group_by(cluster) %>%
          dplyr::summarize(index = sum(row)/n()) %>%
          dplyr::arrange(desc(index)) %>%
          dplyr::pull(cluster) %>%
          match(seq_len(k), .)
        df_kmeans$cluster <- order[df_kmeans$cluster]
      }
      if(type == "contrast") {
        # Order the k-means clusters according to their average fold change
        order <- cbind(df, cluster = df_kmeans$cluster) %>%
          dplyr::gather(condition, diff, -cluster) %>%
          dplyr::group_by(cluster) %>%
          dplyr::summarize(row = mean(diff)) %>%
          dplyr::arrange(desc(row)) %>%
          dplyr::pull(cluster) %>%
          match(seq_len(k), .)
        df_kmeans$cluster <- order[df_kmeans$cluster]
      }
    } else {
      df_kmeans <- NULL
    }
  }
  
  if(ncol(df) == 1) {
    col_clust = FALSE
  } else {
    col_clust = TRUE
  }
  # if(nrow(df) == 1) {
  #   row_clust = FALSE
  # } else {
  #   row_clust = TRUE
  # }
  if(clustering_distance == "gower") {
    clustering_distance <- function(x) {
      dist <- cluster::daisy(x, metric = "gower")
      dist[is.na(dist)] <- max(dist, na.rm = TRUE)
      return(dist)
    }
  }
  
  # Legend info
  legend <- ifelse(type == "contrast",
                   "log2 Fold change",
                   "log2 Centered intensity")
  
  # Heatmap
  if(!is.null(df_kmeans)){
    ht1 = Heatmap(df,
                  col = circlize::colorRamp2(
                    seq(-col_limit, col_limit, (col_limit/5)),
                    rev(RColorBrewer::brewer.pal(11, "RdBu"))),
                  split = if(kmeans) {df_kmeans$cluster} else {NULL},
                  cluster_rows = col_clust,
                  cluster_columns = cluster_columns,
                  row_names_side = "left",
                  column_names_side = "top",
                  clustering_distance_rows = clustering_distance,
                  clustering_distance_columns = clustering_distance,
                  heatmap_legend_param = list(color_bar = "continuous",
                                              legend_direction = "horizontal",
                                              legend_width = unit(5, "cm"),
                                              title_position = "lefttop"),
                  name = legend,
                  row_names_gp = gpar(fontsize = row_font_size),
                  column_names_gp = gpar(fontsize = col_font_size),
                  top_annotation = ha1)
    p <- draw(ht1, heatmap_legend_side = "top")
    row_clusters<- row_order(p)
  } else {
    p <-ggplot() +
        annotate("text", x = 1,  y = 1,
                 size = 7,
                 label = "Heatmap could not be performed.\nPlease set the number of clusters less than \nthe number of significant proteins") + 
        theme_void()
    row_clusters<- NULL
  }
  
  heatmap_list <- list(p, row_clusters)
  return(heatmap_list)
}

# Internal function to get ComplexHeatmap::HeatmapAnnotation object
get_annotation <- function(dep, indicate) {
  assertthat::assert_that(
    inherits(dep, "SummarizedExperiment"),
    is.character(indicate))
  
  # Check indicate columns
  col_data <- colData(dep) %>%
    as.data.frame()
  columns <- colnames(col_data)
  if(all(!indicate %in% columns)) {
    stop("'",
         paste0(indicate, collapse = "' and/or '"),
         "' column(s) is/are not present in ",
         deparse(substitute(dep)),
         ".\nValid columns are: '",
         paste(columns, collapse = "', '"),
         "'.",
         call. = FALSE)
  }
  if(any(!indicate %in% columns)) {
    indicate <- indicate[indicate %in% columns]
    warning("Only used the following indicate column(s): '",
            paste0(indicate, collapse = "', '"),
            "'")
  }
  
  # Get annotation
  anno <- dplyr::select(col_data, all_of(indicate))
  
  # Annotation color
  names <- colnames(anno)
  anno_col <- vector(mode="list", length=length(names))
  names(anno_col) <- names
  for(i in names) {
    var = anno[[i]] %>% unique() %>% sort()
    if(length(var) == 1)
      cols <- c("black")
    if(length(var) == 2)
      cols <- c("orangered", "cornflowerblue")
    if(length(var) <= 7 & length(var) > 2)
      cols <- RColorBrewer::brewer.pal(length(var), "Pastel1")
    if(length(var) <= 12 & length(var) > 7)
      cols <- RColorBrewer::brewer.pal(length(var), "Set3")
    if(length(var) > 12)
      # cols <- c(RColorBrewer::brewer.pal(12, "Set3"),
      #           RColorBrewer::brewer.pal(8, "Set2"),
      #           RColorBrewer::brewer.pal(9, "Set1"),
      #           RColorBrewer::brewer.pal(8, "Pastel2"),
      #           RColorBrewer::brewer.pal(9, "Pastel1"))[1:length(var)]
      cols <- scales::hue_pal()(length(var))
    names(cols) <- var
    anno_col[[i]] <-  cols
  }
  
  # HeatmapAnnotation object
  ComplexHeatmap::HeatmapAnnotation(df = anno,
                    col = anno_col,
                    show_annotation_name = TRUE)
}


#### ===== limma BH FDR ===== #####

test_limma <- function(se, type = c("control", "all", "manual"),
                       control = NULL, test = NULL,
                       design_formula = formula(~ 0 + condition),
                       paired = FALSE) {
  #require("dplyr", "tidyr", "purrr")
  
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(se, "SummarizedExperiment"),
                          is.character(type),
                          class(design_formula) == "formula")
  # if (paired == FALSE){
  #   design_formula <- design_formula
  # }else{
  #   design_formula<-formula(~ 0 + condition + replicate)
  # }

  
  # Show error if inputs do not contain required columns
  type <- match.arg(type)
  
  col_data <- colData(se)
  raw <- assay(se)
  
  if(any(!c("name", "ID") %in% colnames(rowData(se)))) {
    stop("'name' and/or 'ID' columns are not present in '",
         deparse(substitute(se)),
         "'\nRun make_unique() and make_se() to obtain the required columns",
         call. = FALSE)
  }
  if(any(!c("label", "condition", "replicate") %in% colnames(col_data))) {
    stop("'label', 'condition' and/or 'replicate' columns are not present in '",
         deparse(substitute(se)),
         "'\nRun make_se() or make_se_parse() to obtain the required columns",
         call. = FALSE)
  }
  if(any(is.na(raw))) {
    warning("Missing values in '", deparse(substitute(se)), "'")
  }
  
  if(!is.null(control)) {
    # Show error if control input is not valid
    assertthat::assert_that(is.character(control),
                            length(control) == 1)
    if(!control %in% unique(col_data$condition)) {
      stop("run test_diff() with a valid control.\nValid controls are: '",
           paste0(unique(col_data$condition), collapse = "', '"), "'",
           call. = FALSE)
    }
  }
  
  # variables in formula
  variables <- terms.formula(design_formula) %>%
    attr(., "variables") %>%
    as.character() %>%
    .[-1]
  
  # Throw error if variables are not col_data columns
  if(any(!variables %in% colnames(col_data))) {
    stop("run make_diff() with an appropriate 'design_formula'")
  }
  if(variables[1] != "condition") {
    stop("first factor of 'design_formula' should be 'condition'")
  }
  
  # Obtain variable factors
  for(var in variables) {
    temp <- factor(col_data[[var]])
    assign(var, temp)
  }
  
  # Make an appropriate design matrix
  design <- model.matrix(design_formula, data = environment())
  colnames(design) <- gsub("condition", "", colnames(design))
  
  # Generate contrasts to be tested
  # Either make all possible combinations ("all"),
  # only the contrasts versus the control sample ("control") or
  # use manual contrasts
  conditions <- as.character(unique(condition))
  if(type == "all") {
    # All possible combinations
    cntrst <- apply(utils::combn(conditions, 2), 2, paste, collapse = " - ")
    
    if(!is.null(control)) {
      # Make sure that contrast containing
      # the control sample have the control as denominator
      flip <- grep(paste("^", control, sep = ""), cntrst)
      if(length(flip) >= 1) {
        cntrst[flip] <- cntrst[flip] %>%
          gsub(paste(control, "- ", sep = " "), "", .) %>%
          paste(" - ", control, sep = "")
      }
    }
    
  }
  if(type == "control") {
    # Throw error if no control argument is present
    if(is.null(control))
      stop("run test_diff(type = 'control') with a 'control' argument")
    
    # Make contrasts
    cntrst <- paste(conditions[!conditions %in% control],
                    control,
                    sep = " - ")
  }
  if(type == "manual") {
    # Throw error if no test argument is present
    if(is.null(test)) {
      stop("run test_diff(type = 'manual') with a 'test' argument")
    }
    assertthat::assert_that(is.character(test))
    
    if(any(!unlist(strsplit(test, "_vs_")) %in% conditions)) {
      stop("run test_diff() with valid contrasts in 'test'",
           ".\nValid contrasts should contain combinations of: '",
           paste0(conditions, collapse = "', '"),
           "', for example '", paste0(conditions[1], "_vs_", conditions[2]),
           "'.", call. = FALSE)
    }
    
    cntrst <- gsub("_vs_", " - ", test)
    
  }
  # Print tested contrasts
  message("Tested contrasts: ",
          paste(gsub(" - ", "_vs_", cntrst), collapse = ", "))
  
  # Test for differential expression by empirical Bayes moderation
  # of a linear model on the predefined contrasts
  fit <- lmFit(raw, design = design)
  made_contrasts <- makeContrasts(contrasts = cntrst, levels = design)
  contrast_fit <- contrasts.fit(fit, made_contrasts)
  
  if(any(is.na(raw))) {
    for(i in cntrst) {
      covariates <- strsplit(i, " - ") %>% unlist
      single_contrast <- makeContrasts(contrasts = i, levels = design[, covariates])
      single_contrast_fit <- contrasts.fit(fit[, covariates], single_contrast)
      contrast_fit$coefficients[, i] <- single_contrast_fit$coefficients[, 1]
      contrast_fit$stdev.unscaled[, i] <- single_contrast_fit$stdev.unscaled[, 1]
    }
  }
  
  eB_fit <- eBayes(contrast_fit)
  
  # function to retrieve the results of
  # the differential expression test using 'fdrtool'
  retrieve_fun <- function(comp, fit = eB_fit){
    res <- topTable(fit, sort.by = "t", adjust.method="BH", coef = comp,
                    number = Inf, confint = TRUE)
    # res <- res[!is.na(res$t),]
    #fdr_res <- fdrtool::fdrtool(res$t, plot = FALSE, verbose = FALSE)
    # res$qval <- res$adj.P.Value
    #res$lfdr <- fdr_res$lfdr
    res$comparison <- rep(comp, dim(res)[1])
    res <- tibble::rownames_to_column(res)
    return(res)
  }
  
  #limma_res<- topTable(eB_fit, sort.by = 'B', adjust.method="BH", coef = cntrst, number = Inf, confint = T )
  # limma_res$comparison <- rep(cntrst, dim(limma_res)[1])
  #limma_res <- rownames_to_column(limma_res)
  # Retrieve the differential expression test results
  limma_res <- purrr::map_df(cntrst, retrieve_fun)
  
  # Select the logFC, CI and qval variables
  table <- limma_res %>%
    dplyr::select(rowname, logFC, CI.L, CI.R, P.Value, adj.P.Val, comparison) %>%
    dplyr::mutate(comparison = gsub(" - ", "_vs_", comparison)) %>%
    tidyr::gather(variable, value, -c(rowname,comparison)) %>%
    dplyr::mutate(variable = dplyr::recode(variable, logFC = "diff", P.Value = "p.val", adj.P.Val = "p.adj")) %>%
    tidyr::unite(temp, comparison, variable) %>%
    tidyr::spread(temp, value)
  
  #TODO: temporary solution of avoid wrong order of similar comparison names
  comp_list <- sort(gsub(" - ", "_vs_", cntrst))
  ordered_colNames <- c("rowname" ,
                        lapply(comp_list, function(x) colnames(table)[grep(paste0(x, "(_CI.L|_CI.R|_diff|_p.adj|_p.val)"), colnames(table))]) %>% unlist())
  
  table <- table %>% select(all_of(ordered_colNames))
  
  rowData(se) <- merge(rowData(se), table,
                       by.x = "name", by.y = "rowname", all.x = TRUE)
  return(se)
  #return(table)
}

get_results_tmt_proteins <- function(dep) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(dep, "SummarizedExperiment"))
  
  row_data <- rowData(dep)
  # Show error if inputs do not contain required columns
  if(any(!c("name", "ID") %in% colnames(row_data))) {
    stop("'name' and/or 'ID' columns are not present in '",
         deparse(substitute(dep)),
         "'\nRun make_unique() and make_se() to obtain the required columns",
         call. = FALSE)
  }
  if(length(grep("_p.adj|_diff", colnames(row_data))) < 1) {
    stop("'[contrast]_diff' and/or '[contrast]_p.adj' columns are not present in '",
         deparse(substitute(dep)),
         "'\nRun test_diff() to obtain the required columns",
         call. = FALSE)
  }
  
  # Obtain average protein-centered enrichment values per condition
  row_data$mean <- rowMeans(assay(dep), na.rm = TRUE)
  centered <- assay(dep) - row_data$mean
  centered <- data.frame(centered) %>%
    tibble::rownames_to_column() %>%
    tidyr::gather(ID, val, -rowname) %>%
    dplyr::left_join(., data.frame(colData(dep)), by = "ID")
  centered <- dplyr::group_by(centered, rowname, condition) %>%
    dplyr::summarize(val = mean(val, na.rm = TRUE)) %>%
    dplyr::mutate(val = signif(val, digits = 3)) %>%
    tidyr::spread(condition, val)
  colnames(centered)[2:ncol(centered)] <-
    paste(colnames(centered)[2:ncol(centered)], "_centered", sep = "")
  
  # Obtain average enrichments of conditions versus the control condition
  ratio <- as.data.frame(row_data) %>%
    # tibble::column_to_rownames("name") %>%
    dplyr::select(dplyr::ends_with("diff")) %>%
    signif(., digits = 3) %>%
    tibble::rownames_to_column()
  colnames(ratio)[2:ncol(ratio)] <-
    gsub("_diff", "_log2 fold change", colnames(ratio)[2:ncol(ratio)])
 # df <- left_join(ratio, centered, by = "rowname")
  
  # Select the adjusted p-values and significance columns
  pval <- as.data.frame(row_data) %>%
    # tibble::column_to_rownames("name") %>%
    dplyr::select(dplyr::ends_with("p.val"),
                  dplyr::ends_with("p.adj"),
                  dplyr::ends_with("significant")) %>%
   tibble::rownames_to_column()
  pval[, grep("p.adj", colnames(pval))] <-
    pval[, grep("p.adj", colnames(pval))] %>%
    signif(digits = 3)
  pval[, grep("p.val", colnames(pval))] <-
    pval[, grep("p.val", colnames(pval))] %>%
    signif(digits = 3)
  
  # Obtain overall mean abundance and mean abundance of each condition
  intensity_df <- assay(dep) %>% data.frame()
  exp_design <- colData(dep) %>% data.frame()
  conditions <- exp_design$condition %>% unique()
  
  intensity_df$mean_abundance <- rowMeans(as.matrix(intensity_df), na.rm = TRUE)
  intensity_df$rank <- rank(-intensity_df$mean_abundance)
  
  for (i in 1:length(conditions)) {
    condition <- conditions[i]
    pattern <- paste(condition,"[[:digit:]]",sep = '_')
    intensity_df[paste0('mean',sep = "_",condition)] <- rowMeans(
      as.matrix(intensity_df %>% 
                  select(grep(pattern, colnames(intensity_df)))), na.rm = TRUE)
  }
  
  mean_df <- intensity_df %>%
    dplyr::select(dplyr::starts_with("mean"),
                  "rank") %>%
    tibble::rownames_to_column()
  
  # Join into a results table
  ids <- as.data.frame(row_data) %>% dplyr::select(name, ID)
  table<-dplyr::left_join(ids,ratio, by=c("name"="rowname"))
  table <- dplyr::left_join(table, pval, by = c("name" = "rowname"))
  table <- dplyr::left_join(table, mean_df, by = c("name" = "rowname"))
  # table <- dplyr::left_join(table, centered, by = c("name" = "rowname")) %>%
  #   dplyr::arrange(desc(significant))
  table<-as.data.frame(row_data)[, colnames(row_data) %in% c("name","razor_plus_unique_peptides","imputed", "num_NAs", "Description")] %>%
    dplyr::left_join(table, ., by = "name")
  table<-table %>% dplyr::arrange(desc(significant))
  # 
  # if ("" %in% table$name){
  #   table$name[table$name ==""] <- "NoGeneNameAvailable"}
  # if ("" %in% table$Protein.names){
  #   table$Protein.names[table$Protein.names ==""] <- "NoProteinNameAvailable"}
  
  colnames(table)[1]<-c("Gene Name")
  colnames(table)[2]<-c("Protein IDs")
  # if("Gene.Symbol" %in% colnames(table)){
  #   table <- table %>% dplyr::relocate(`Gene.Symbol`, .after = `Protein IDs`)
  #   colnames(table)[colnames(table) == "Gene.Symbol"]<-c("Gene Name")
  # }
  if ("Description" %in% colnames(table)){
    table <- table %>% dplyr::relocate(Description, .after = last_col())
  }
  return(table)
}

                                  
                                  
#######################################################
## Plot Enrichment Results
#######################################################

plot_enrichment <- function(gsea_results, number = 10, alpha = 0.05,
                            contrasts = NULL, databases = NULL,
                            nrow = 1,term_size = 8) {
  assertthat::assert_that(is.data.frame(gsea_results),
                          is.numeric(number),
                          length(number) == 1,
                          is.numeric(alpha),
                          length(alpha) == 1,
                          is.numeric(term_size),
                          length(term_size) == 1,
                          is.numeric(nrow),
                          length(nrow) == 1)
  
  # Check gsea_results object
  if(any(!c("Term", "var",
            "contrast","Adjusted.P.value")
         %in% colnames(gsea_results))) {
    stop("'", deparse(substitute(gsea_results)),
         "' does not contain the required columns",
         "\nMake sure that HGNC gene symbols are present",
	"\n in your 'Gene Names' column of Results table",
         call. = FALSE)
  }
  
  no_enrichment_text <- paste("Enrichment could not be performed.\n",
                              "\nDownload enrichment result table for more details. \n")
  
  if(!is.null(contrasts)) {
    assertthat::assert_that(is.character(contrasts))
    
    valid_contrasts <- unique(gsea_results$contrast)
    
    if(!all(contrasts %in% valid_contrasts)) {
      # valid_cntrsts_msg <- paste0("Valid contrasts are: '",
      #                             paste0(valid_contrasts, collapse = "', '"),
      #                             "'")
      # stop("Not a valid contrast, please run `plot_gsea()`",
      #      "with a valid contrast as argument\n",
      #      valid_cntrsts_msg,
      #      call. = FALSE)
      return(ggplot() +
               annotate("text", x = 4, y = 25, size=8, label = no_enrichment_text) +
               theme_void()
      )
    }
    if(!any(contrasts %in% valid_contrasts)) {
      contrasts <- contrasts[contrasts %in% valid_contrasts]
      message("Not all contrasts found",
              "\nPlotting the following contrasts: '",
              paste0(contrasts, collapse = "', '"), "'")
    }
    
    gsea_results <- filter(gsea_results, contrast %in% contrasts)
  }
  if(!is.null(databases)) {
    assertthat::assert_that(is.character(databases))
    
    valid_databases <- unique(gsea_results$var)
    
    if(all(!databases %in% valid_databases)) {
      valid_cntrsts_msg <- paste0("Valid databases are: '",
                                  paste0(valid_databases, collapse = "', '"),
                                  "'")
      stop("Not a valid database, please run `plot_gsea()`",
           "with valid databases as argument\n",
           valid_cntrsts_msg,
           call. = FALSE)
    }
    if(any(!databases %in% valid_databases)) {
      databases <- databases[databases %in% valid_databases]
      message("Not all databases found",
              "\nPlotting the following databases: '",
              paste0(databases, collapse = "', '"), "'")
    }
    
    gsea_results <- filter(gsea_results, var %in% databases)
  }
  
  # Get top enriched gene sets
  terms <- gsea_results %>%
    dplyr::group_by(contrast, var) %>%
    dplyr::filter(Adjusted.P.value <= alpha) %>%
    dplyr::arrange(Adjusted.P.value) %>%
    dplyr::slice(seq_len(number)) %>%
    .$Term
  subset <- gsea_results %>%
    dplyr::filter(Term %in% terms) %>%
    dplyr::arrange(var, Adjusted.P.value)
  
  subset$Term <- readr::parse_factor(subset$Term, levels = unique(subset$Term))
  subset$var <- readr::parse_factor(subset$var, levels = unique(subset$var))
  
  # Plot top enriched gene sets
  if(nrow(subset) == 0){
    p <- ggplot() +
      annotate("text", x = 4, y = 25, size=7, label = no_enrichment_text) + 
      theme_void()
  } else {
    p<-ggplot(subset, aes(Term,
                          y=-log10(`Adjusted.P.value`))) +
      geom_col(aes(fill = log_odds )) +
      facet_wrap(~contrast, nrow = nrow) +
      coord_flip() +
      labs(y = "-Log10 adjusted p-value",
           fill = "Log2 odds ratio (vs. current background)") +
      theme_bw() +
      theme(legend.position = "top",
            legend.text = element_text(size = 9)) +
      scale_fill_distiller(palette="Spectral")
  }
}
                                  
#### ==== get prefix function 

get_prefix <- function(words) {
  # Show error if input is not the required class
  assertthat::assert_that(is.character(words))
  
  # Show error if 'words' contains 1 or less elements
  if(length(words) <= 1) {
    stop("'words' should contain more than one element")
  }
  # Show error if 'words' contains NA
  if(any(is.na(words))) {
    stop("'words' contains NAs")
  }
  
  # Truncate words to smallest name
  minlen <- min(nchar(words))
  truncated <- substr(words, 1, minlen)
  
  # Show error if one of the elements is shorter than one character
  if(minlen < 1) {
    stop("At least one of the elements is too short")
  }
  
  # Get identifical characters
  mat <- data.frame(strsplit(truncated, ""), stringsAsFactors = FALSE)
  identical <- apply(mat, 1, function(x) length(unique(x)) == 1)
  
  # Obtain the longest common prefix
  prefix <- as.logical(cumprod(identical))
  paste(mat[prefix, 1], collapse = "")
}

#### ===== delete prefix function

delete_prefix <- function(words) {
  # Get prefix
  prefix <- get_prefix(words)
  # Delete prefix from words
  gsub(paste0("^", prefix), "", words)
}

#### function to create exp_design template
get_tmt_exp_design <- function(df){
  
  intensity_cols <- grep("Abundances \\(Grouped\\):", colnames(df))
  intensity_names <- colnames(df[,intensity_cols])
  
  intensity_names <- stringr::str_sort(intensity_names, numeric = TRUE) # sort the intensity columns
  
  df <- data.frame(label = intensity_names) %>% 
    add_column(condition = NA, replicate = NA, batch = NA)
  # change the replicate to numeric
  df$replicate = as.integer(df$replicate)
  df$batch = as.character(df$batch)
  return(df)
}

#### customize PCA plot from DEP package ####
plot_pca_new <- function(dep, x = 1, y = 2, indicate = c("condition", "replicate"),
                     label = FALSE, n = 500, point_size = 4, label_size = 4, plot = TRUE) {
  if(is.integer(x)) x <- as.numeric(x)
  if(is.integer(y)) y <- as.numeric(y)
  if(is.integer(n)) n <- as.numeric(n)
  if(is.integer(point_size)) point_size <- as.numeric(point_size)
  if(is.integer(label_size)) label_size <- as.numeric(label_size)
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(dep, "SummarizedExperiment"),
                          is.numeric(x),
                          length(x) == 1,
                          is.numeric(y),
                          length(y) == 1,
                          is.numeric(n),
                          length(n) == 1,
                          is.character(indicate),
                          is.logical(label),
                          is.numeric(point_size),
                          length(point_size) == 1,
                          is.numeric(label_size),
                          length(label_size) == 1,
                          is.logical(plot),
                          length(plot) == 1)
  
  # Check for valid x and y values
  if(x > ncol(dep) | y > ncol(dep)) {
    stop(paste0("'x' and/or 'y' arguments are not valid\n",
                "Run plot_pca() with 'x' and 'y' <= ",
                ncol(dep), "."),
         call. = FALSE)
  }
  
  # Check for valid 'n' value
  if(n > nrow(dep)) {
    stop(paste0("'n' argument is not valid.\n",
                "Run plot_pca() with 'n' <= ",
                nrow(dep),
                "."),
         call. = FALSE)
  }
  
  # Check for valid 'indicate'
  columns <- colnames(colData(dep))
  if(!is.null(indicate)) {
    if(length(indicate) > 3) {
      stop("Too many features in 'indicate'
        Run plot_pca() with a maximum of 3 indicate features")
    }
    if(any(!indicate %in% columns)) {
      stop(paste0("'",
                  paste0(indicate, collapse = "' and/or '"),
                  "' column(s) is/are not present in ",
                  deparse(substitute(dep)),
                  ".\nValid columns are: '",
                  paste(columns, collapse = "', '"),
                  "'."),
           call. = FALSE)
    }
  }
  
  # Get the variance per protein and take the top n variable proteins
  var <- apply(assay(dep), 1, sd)
  df <- assay(dep)[order(var, decreasing = TRUE)[seq_len(n)],]
  
  # Calculate PCA
  pca <- prcomp(t(df), scale = FALSE)
  pca_df <- pca$x %>%
    data.frame() %>%
    rownames_to_column() %>%
    left_join(., data.frame(colData(dep)), by = c("rowname" = "ID"))
  
  # Calculate the percentage of variance explained
  percent <- round(100 * pca$sdev^2 / sum(pca$sdev^2), 1)
  
  # Make factors of indicate features
  for(feat in indicate) {
    pca_df[[feat]] <- as.factor(pca_df[[feat]])
  }
  
  # Plot the PCA plot
  p <- ggplot(pca_df, aes(get(paste0("PC", x)), get(paste0("PC", y)))) +
    labs(title = paste0("PCA plot - top ", n, " variable proteins"),
         x = paste0("PC", x, ": ", percent[x], "%"),
         y = paste0("PC", y, ": ", percent[y], "%")) +
    coord_fixed() +
    theme_DEP1()
  
  if(length(indicate) == 0) {
    p <- p + geom_point(size = point_size)
  }
  if(length(indicate) == 1) {
    p <- p + geom_point(aes(col = .data[[indicate[1]]]),
                        size = point_size) +
      labs(col = indicate[1])
  }
  if(length(indicate) == 2) {
    p <- p + geom_point(aes(col = .data[[indicate[1]]],
                            shape = .data[[indicate[2]]]),
                        size = point_size) +
      labs(col = indicate[1],
           shape = indicate[2])
  }
  if(length(indicate) == 3) {
    p <- p + geom_point(aes(col = .data[[indicate[1]]],
                            shape = .data[[indicate[2]]]),
                        size = point_size) +
      facet_wrap(~.data[[indicate[3]]])
    labs(col = indicate[1],
         shape = indicate[2])
  }
  if(label) {
    # p <- p + geom_text(aes(label = rowname), size = label_size)
    p <- p + ggrepel::geom_text_repel(aes(label=factor(rowname)),
                                      size = label_size,
                                      box.padding = unit(0.1, 'lines'),
                                      point.padding = unit(0.1, 'lines'),
                                      segment.size = 0.5)
  }
  if(plot) {
    return(p)
  } else {
    df <- pca_df %>%
      select(rowname, paste0("PC", c(x, y)), match(indicate, colnames(pca_df)))
    colnames(df)[1] <- "sample"
    return(df)
  }
}

# missing value heatmap with percentage
plot_missval_new <- function(se,fontsize = 10) {
  # Show error if input is not the required classes
  assertthat::assert_that(inherits(se, "SummarizedExperiment"))
  
  se_assay <- assay(se)
  # # Show error if there are no missing values
  # if(!any(is.na(se_assay))) {
  #   stop("No missing values in '", deparse(substitute(se)), "'",
  #        call. = FALSE)
  # }
  # 
  # Make assay data binary (1 = valid value, 0 = missing value)
  df <- se_assay %>% data.frame(.)
  colnames(df) <- paste0(colnames(df), " (", round((colMeans(is.na(df)))*100,2), "%)")
  missval <- df[apply(df, 1, function(x) any(is.na(x))), ]
  missval <- ifelse(is.na(missval), 0, 1)
  
  
  
  # Plot binary heatmap()
  # Show message if there are no missing values
  if(!any(is.na(se_assay))) {
    p <- ggplot() +
      annotate("text", x = 1,  y = 1,
               size = 7,
               label = "No missing values in dataset") + 
      theme_void()
  } else {
    ht2 = Heatmap(missval,
                  col = c("white", "black"),
                  column_names_side = "top",
                  show_row_names = FALSE,
                  show_column_names = TRUE,
                  name = "Missing values pattern",
                  column_names_gp = gpar(fontsize = fontsize),
                  heatmap_legend_param = list(at = c(0, 1),
                                              labels = c("Missing value", "Valid value")))
    p <- draw(ht2, heatmap_legend_side = "top")
  }
  return(p)
}

# entire missing value heatmap
plot_missval_full <- function(se, indicate="condition",fontsize = 10){
  df <- assay(se) %>% as.matrix(.)
  df[is.na(df)] = 0
  
  
  
  col_range <- seq(max(df),0, -(max(df)/7))
  used_color = circlize::colorRamp2(col_range,c("#800f26", "#bd1a26","#e3211c","#fc4e2a","#fd8d3c","#fed976","#ffeda0","#ffffff"))
  scale_list <- seq(0, plyr::round_any(max(df),5,ceiling),10)
  
  if(ncol(df) == 1) {
    col_clust = FALSE
  } else {
    col_clust = TRUE
  }
  if(nrow(df) == 1) {
    row_clust = FALSE
  } else {
    row_clust = TRUE
  }
  Color_heatmap <- Heatmap(df,
                           col = used_color,
                           cluster_rows = col_clust,
                           cluster_columns = row_clust,
                           show_row_names = FALSE,
                           show_column_names = TRUE,
                           column_names_side = "top",
                           column_names_gp = gpar(fontsize = fontsize),
                           name = "Log2 transformed",
                           heatmap_legend_param = list(color_bar = "continuous",
                                                       legend_direction = "horizontal",
                                                       legend_width = unit(5, "cm"),
                                                       title_position = "lefttop",
                                                       at = scale_list,
                                                       labels = scale_list),
                           top_annotation = get_annotation(se,indicate)
  )
  
  Color_heatmap1 <- draw(Color_heatmap, heatmap_legend_side = "top")
  return(Color_heatmap1)
}

### Filter missing values use different threshold per conditions/groups
threshold_detect <- function(sample_rep){
  if(sample_rep<3){
    threshold<-0
  } else  if(sample_rep==3){
    threshold<-1
  } else if(sample_rep<6 ){
    threshold<-2
  } else if (sample_rep>=6){
    threshold<-trunc(sample_rep/2)
  }
  return(threshold)
}

keep_function_no_ref <- function(se){
  # Show error if inputs are not the required classes
  
  # Show error if inputs do not contain required columns
  if(any(!c("name", "ID") %in% colnames(rowData(se, use.names = FALSE)))) {
    stop("'name' and/or 'ID' columns are not present in '",
         deparse(substitute(se)),
         "'\nRun make_unique() and make_se() to obtain the required columns",
         call. = FALSE)
  }
  if(any(!c("label", "condition", "replicate") %in% colnames(colData(se)))) {
    stop("'label', 'condition' and/or 'replicate' columns are not present in '",
         deparse(substitute(se)),
         "'\nRun make_se() or make_se_parse() to obtain the required columns",
         call. = FALSE)
  }
  
  # Make assay values binary (1 = valid value)
  bin_data <- assay(se)
  
  # new, removed ref columns from dataset
  bin_data <- bin_data %>% data.frame() %>% select(!contains("Ref", ignore.case = TRUE)) # new add
  idx <- is.na(bin_data) # idx <- is.na(assay(se))
  bin_data[!idx] <- 1
  bin_data[idx] <- 0
  
  # Filter se on the maximum allowed number of
  # missing values per condition (defined by thr)
  keep <- bin_data %>%
    data.frame() %>%
    rownames_to_column() %>%
    gather(ID, value, -rowname) %>%
    left_join(., data.frame(colData(se)), by = "ID") %>%
    group_by(rowname, condition) %>%
    summarize(miss_val = n() - sum(value))
  return(keep)
}

filter_missval_no_ref <- function(se,one_condition,exp_df){
  threshold <- exp_df$thr[exp_df$condition==one_condition] %>% unlist()
  keep <- keep_function_no_ref(se)
  keep1 <- keep %>% 
    dplyr::filter(condition == one_condition) %>%
    dplyr::filter(miss_val <= threshold)
  keep1 <- keep1 %>%
    tidyr::spread(condition, miss_val)
  se_fltrd <- se[keep1$rowname, ]
  return(se_fltrd)
}

gene_name_extract <- function(data,description){
  
  # if doesn't contain "GN=|Gene_Symbol=" replace to blank
  data[[description]][!grepl('GN=|Gene_Symbol=',data[[description]])] <- ''

  data <-data %>% dplyr::mutate(Gene.names= gsub(".* GN=", "",data[[description]]))
  data <-data %>% dplyr::mutate(Gene.names= gsub(" PE.*", "",Gene.names))
  data <-data %>% dplyr::mutate(Gene.names= gsub("protein .*", "",Gene.names))
  data <-data %>% dplyr::mutate(Gene.names= gsub(" OS.*", "",Gene.names))
  data <-data %>% dplyr::mutate(Gene.names= gsub(".* Gene_Symbol=", "",Gene.names))
  data <-data %>% dplyr::mutate(Gene.names= gsub("[[:blank:]].*", "",Gene.names))
  data <-data %>% dplyr::mutate(Gene.names= gsub("-", "",Gene.names))
  
  data <- data %>% dplyr::relocate(Gene.names, .before = Accession )
  return(data)
}

read_exp_func <- function(inFile){
  if (grepl(".csv",inFile$name)){
    temp_df<-read.csv(inFile$datapath,
                      header = TRUE,
                      sep=",",
                      stringsAsFactors = FALSE,
                      # colClasses = c(label = "character",condition = "character")
                      colClasses = "character"
                      )
  } else if (grepl(".xlsx",inFile$name)){
    temp_df<- readxl::read_excel(inFile$datapath,
                                 sheet = NULL,
                                 col_names = TRUE,
                                 na = "",
                                 col_types = "text"
                                 )
  } else {
    temp_df<-read.delim(inFile$datapath,
                        header = TRUE,
                        sep="\t",
                        stringsAsFactors = FALSE,
                        # colClasses = c(label = "character",condition = "character")
                        colClasses = "character"
                        )
    
    if (ncol(temp_df) == 1){
      temp_df<-read.delim(inFile$datapath,
                          header = TRUE,
                          sep=" ",
                          stringsAsFactors = FALSE,
                          # colClasses = c(label = "character",condition = "character")
                          colClasses = "character"
                          )
    }
  }
  temp_df$label <- temp_df$label %>% gsub(", Sample", "",.) #TODO: find a better way to avoid this 
  return(temp_df)
}

read_exp_func_new <- function(inFile){
  if (grepl(".csv",inFile)){
    temp_df<-read.csv(inFile,
                      header = TRUE,
                      sep=",",
                      stringsAsFactors = FALSE,
                      # colClasses = c(label = "character",condition = "character")
                      colClasses = "character"
                      )
  } else if (grepl(".xlsx",inFile)){
    temp_df<- readxl::read_excel(inFile,
                                 sheet = NULL,
                                 col_names = TRUE,
                                 na = "",
                                 col_types = "text"
                                 )
  } else {
    print("not .xlsx not csv")
    print(inFile)
    temp_df<-read.delim(inFile,
                        header = TRUE,
			fill = TRUE,
                        sep = "\t",
			quote = "",
			comment.char = "",
                        stringsAsFactors = FALSE,
                        # colClasses = c(label = "character",condition = "character")
                        colClasses = "character"
                        )
     print(temp_df)
     print("After temp df")
    if (ncol(temp_df) == 1){
      temp_df<-read.delim(inFile,
                          header = TRUE,
                          sep=" ",
                          stringsAsFactors = FALSE,
                          # colClasses = c(label = "character",condition = "character")
                          colClasses = "character"
                          )
    }
  }
  print("before temp label and it's where the problem occurs")
  print(temp_df)
  print(temp_df$label) ## input experiment file does not have label header
  temp_df$label <- temp_df$label %>% gsub(", sample", "",.) #TODO: find a better way to avoid this
  #temp_df$sample <- temp_df$sample %>% gsub(", sample", "",.)
  print("after temp label")
  return(temp_df)
}

# IRS normalisation (after imputation)
# sample loading normalisation
sl_norm_func <- function(se, exp_design){
  tmt_intensity<-2^assay(se)
  colnames(tmt_intensity) <- paste0(colData(se)$ID, "-",colData(se)$batch) 
  
  ### sample loading normalization
  batch_list <- exp_design$batch %>% unique() %>% sort()
  
  raw_df_function <- function(batch){
    df <- tmt_intensity %>% data.frame(.) %>% 
      dplyr::select(grep(paste0(".", batch,"$"),colnames(tmt_intensity %>% data.frame(.)))) %>% as.matrix(.)
  }
  
  df_list <- lapply(batch_list, raw_df_function)
  
  #rename each df
  raw_names <- paste0("exp", 1:length(batch_list), "_raw")
  names(df_list) <- raw_names
  
  df_list_1 <- lapply(df_list, function(x) colSums(x,na.rm = T))
  
  target <- df_list_1  %>% unlist() %>% mean()
  
  # sample loading normalization before irs
  sl_function <- function(df){
    norm_facs <- target / colSums(df, na.rm = T)
    df_sl <- sweep(df, 2, norm_facs, FUN = "*") %>% data.frame() %>% rownames_to_column()
    colnames(df_sl)[1] <- "row_names"
    return(df_sl)
  }
  
  df_list_sl <- lapply(df_list, sl_function)
  
  sl_names <- raw_names %>% gsub("_raw", "_sl",.)
  names(df_list_sl) <- sl_names
  
  data_sl <- df_list_sl %>% purrr::reduce(merge,by='row_names') %>% column_to_rownames(var = "row_names")
  data_sl <- data_sl[sort(row.names(data_sl)),] # make rownames of rowData same order with rownames of assays

  colnames(data_sl) <- colnames(data_sl) %>% gsub("[.].*", "",.)
  data_sl <- data_sl %>% select(rownames(colData(se))) # make same order
  data_sl <- data_sl %>% as.matrix(.)
  rowData <- rowData(se)[sort(row.names(rowData(se))),] # make rownames of rowData same order with rownames of assays
  
  sl_se <-SummarizedExperiment(assays=log2(data_sl),
                                rowData=rowData,
                                colData= colData(se))
  return(sl_se)
}


irs_norm_func <- function(se){
  data_sl <- 2^assay(se) %>% data.frame
  colnames(data_sl) <- paste0(colData(se)$ID, ".",colData(se)$batch) 
  batch_list <- data.frame(colData(se))$batch %>% unique() %>% sort()

  data_ref <- data_sl %>% select(contains(c("Ref","ref")))
  data_ref$average <- apply(data_ref, 1, function(x) exp( mean(log(x))))
  
  # compute the scaling factor vectors for each batch
  irs <- data_ref
  for (i in 1:length(batch_list)) {
    batch <- batch_list[i]
    pattern <- paste0(".", batch)
    if (length(grep(pattern,colnames(irs))) == 1){
      irs[paste0("fac",i)] <- irs$average / irs[,grep(pattern,colnames(irs))]
    } else {
      irs[paste0("fac",i)] <- irs$average / rowSums(irs[,grep(pattern,colnames(irs))])
    }
  } 
  
  #include reference channel
  # create blank dataframe for use
  data_after_irs <- data.frame(matrix(ncol = 0, nrow = nrow(data_sl)))
  rownames(data_after_irs) <- rownames(data_sl)
  
  for (i in 1:length(batch_list)) {
    batch <- batch_list[i]
    pattern <- paste0(".", batch,"$")
    exp_for_irs <- data_sl[,grep(pattern,colnames(data_sl))]
    exp_for_irs <- exp_for_irs * irs[,paste0("fac",i)]
    # make new data frame with IRS normalized data
    data_after_irs <- cbind(data_after_irs, exp_for_irs)
  }
  
  colnames(data_after_irs) <- colnames(data_after_irs) %>% gsub("[.].*", "",.)
  data_after_irs <- data_after_irs %>% select(rownames(colData(se))) # make same order
  data_after_irs <- data_after_irs %>% as.matrix(.)
  
  irs_se <-SummarizedExperiment(assays=log2(data_after_irs),
                                    rowData=rowData(se),
                                    colData= colData(se))
  return(irs_se)
}

# ComBat normalisation (after irs normalisation)
combat_norm_func <- function(se){
  pheno <- colData(se) %>% data.frame(.)  # exp_design
  pheno$batch <- pheno$batch %>% as.factor() %>% as.numeric()
  edata = assay(se) # assay
  batch = pheno$batch
  mod = model.matrix(~as.factor(condition), data=pheno)
  # adjust batch effects based on batch covariate, parametric adjustment
  data_combat_log <-ComBat(dat=edata, batch=batch, mod=mod) # log2 scale
  
  data_after_sva_log <- data_combat_log %>% as.matrix(.)
  
  sva_se<-SummarizedExperiment(assays=data_after_sva_log, # log2 scale
                                    rowData=rowData(se),
                                    colData=colData(se))
  return(sva_se)
}
  
### customized plot imputation and normalisation
plot_imputation_new <- function(labels,se, ...) {
  # Get arguments from call and remove "labels" from the list
  call <- match.call()
  call <- call[-1] 
  arglist <- lapply(call[-1], function(x) x)
  # var.names <- vapply(arglist, deparse, character(1))
  arglist <- lapply(arglist, eval.parent, n = 2)
  # names(arglist) <- var.names
  names(arglist) <- labels
  
  # Show error if inputs are not the required classes
  lapply(arglist, function(x) {
    assertthat::assert_that(inherits(x,
                                     "SummarizedExperiment"),
                            msg = "input objects need to be of class 'SummarizedExperiment'")
    if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(x)))) {
      stop("'label', 'ID', 'condition' and/or 'replicate' ",
           "columns are not present in (one of) the input object(s)",
           "\nRun make_se() or make_se_parse() to obtain the required columns",
           call. = FALSE)
    }
  })
  
  # Function to get a long data.frame of the assay data
  # annotated with sample info
  gather_join <- function(se) {
    assay(se) %>%
      data.frame() %>%
      gather(ID, val) %>%
      left_join(., data.frame(colData(se)), by = "ID")
  }
  
  df <- map_df(arglist, gather_join, .id = "var") %>%
    mutate(var = factor(var, levels = names(arglist)))
  
  # Density plots for different conditions with facet_wrap
  # for original and imputed samles
  ggplot(df, aes(val, col = condition)) +
    geom_density(na.rm = TRUE) +
    facet_wrap(~var, ncol = 1) +
    labs(x = expression(log[2]~"Intensity"), y = "Density") +
    theme_DEP1()
}

plot_normalization_new <- function(labels,indicate = "condition",se, ...) {
  # Get arguments from call and remove "labels" from the list
  call <- match.call()
  call <- call[c(-1,-2)]
  arglist <- lapply(call[-1], function(x) x)
  # var.names <- vapply(arglist, deparse, character(1))
  arglist <- lapply(arglist, eval.parent, n = 2)
  # names(arglist) <- var.names
  names(arglist) <- labels
  
  # Show error if inputs are not the required classes
  lapply(arglist, function(x) {
    assertthat::assert_that(inherits(x,
                                     "SummarizedExperiment"),
                            msg = "input objects need to be of class 'SummarizedExperiment'")
    if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(x)))) {
      stop("'label', 'ID', 'condition' and/or 'replicate' ",
           "columns are not present in (one of) the input object(s)",
           "\nRun make_se() or make_se_parse() to obtain the required columns",
           call. = FALSE)
    }
  })
  
  # Function to get a long data.frame of the assay data
  # annotated with sample info
  gather_join <- function(se) {
    assay(se) %>%
      data.frame() %>%
      gather(ID, val) %>%
      left_join(., data.frame(colData(se)), by = "ID")
  }
  
  df <- map_df(arglist, gather_join, .id = "var") %>%
    mutate(var = factor(var, levels = names(arglist)))
  
  # order by indicate and ID
  df <- df[with(df, order(df[[indicate]],df[["ID"]])), ] #TODO: more test on that
  # Boxplots for conditions with facet_wrap
  # for the original and normalized values
  ggplot(df, aes(x = forcats::fct_inorder(ID), y = val, fill = as.factor(.data[[indicate]]))) +
    geom_boxplot(notch = TRUE, na.rm = TRUE) +
    coord_flip() +
    facet_wrap(~var, ncol = 1) +
    labs(x = "", y = expression(log[2]~"Intensity"), fill =indicate) +
    theme_DEP1()
}

plot_numbers_new <- function(se, plot = TRUE, indicate = "condition") {
  # Show error if input is not the required classes
  assertthat::assert_that(inherits(se, "SummarizedExperiment"),
                          is.logical(plot),
                          length(plot) == 1)
  
  # Make a binary long data.frame (1 = valid value, 0 = missing value)
  df <- assay(se) %>%
    data.frame() %>%
    rownames_to_column() %>%
    gather(ID, bin, -rowname) %>%
    mutate(bin = ifelse(is.na(bin), 0, 1))
  # Summarize the number of proteins identified
  # per sample and generate a barplot
  stat <- df %>%
    group_by(ID) %>%
    summarize(n = n(), sum = sum(bin)) %>%
    left_join(., data.frame(colData(se)), by = "ID")
  
  # stat <- stat[order(stat[[indicate]]),] # order by indicate
  # order by indicate and ID
  stat <- stat[with(stat, order(stat[[indicate]],stat[["ID"]])), ] #TODO: more test on that
  
  p <- ggplot(stat,aes(x = forcats::fct_inorder(ID), y = sum, fill = .data[[indicate]] %>% as.factor())) + 
    geom_col() +
    geom_hline(yintercept = unique(stat$n)) +
    labs(title = "Proteins per sample", x = "",
         y = "Number of proteins",
         fill = indicate) +
    theme_DEP2()
  if(plot) {
    return(p)
  } else {
    df <- as.data.frame(stat)
    colnames(df)[seq_len(3)] <- c("sample", "total_proteins", "proteins_in_sample")
    return(df)
  }
}

# multiscatter plot function
plot_scatter <- function(se,selected_samples,size = 1){
  # Show error if input is not the required classes
  assertthat::assert_that(inherits(se, "SummarizedExperiment"),
                          is.character(selected_samples))
  
  df <- assay(se) %>% data.frame()
  
  # check length of selected samples
  if(length(selected_samples) == 1){
    p <- ggplot() +
      annotate("text", x = 1,  y = 1,
               size = 7,
               label = "Please select at least two samples \nfor the scatterplot matrix") + 
      theme_void()
  } else if (length(selected_samples) > 6){
    p <- ggplot() +
      annotate("text", x = 1,  y = 1,
               size = 7,
               label = "Please select no more than six samples \nfor the scatterplot matrix") + 
      theme_void()
  } else {
    p <- GGally::ggpairs(
      df[, selected_samples],
      upper = list(continuous = wrap("cor", method = "pearson", stars = F, na.rm = T)),
      lower = list(continuous = wrap("points",size = size, shape= 1, na.rm = T)),
      diag = list(continuous = wrap("densityDiag",color = "blue", na.rm = T))
    ) + theme_DEP1()
  }
  return(p)
}
